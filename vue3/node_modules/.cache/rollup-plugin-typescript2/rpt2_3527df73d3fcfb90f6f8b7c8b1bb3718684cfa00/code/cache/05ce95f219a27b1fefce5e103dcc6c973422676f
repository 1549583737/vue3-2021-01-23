{"code":"import { isObject } from './../shared/index';\r\nimport { mutableHandlers } from './baseHandlers';\r\nexport var reactive = function (target) {\r\n    console.log(target);\r\n    // 你给我一个对象，我需要让这个对象变成响应式对象\r\n    // 区别\r\n    // 在vue2.0的时候，defineProperty直接循环对象中的每一个属性，无法对不存在的属性做处理，递归处理多级对象\r\n    // vue3.0没有循环 对源对象进行代理，vue3不存在的属性也可以监测到, vue3没有一上来就递归\r\n    return createReactiveObject(target, mutableHandlers); // 高阶函数，可以根据不同的参数实现不同的功能\r\n};\r\nvar reactiveMap = new WeakMap(); // 映射表中的key必须是对象，而且不会有内存泄漏的问题\r\nfunction createReactiveObject(target, baseHandler) {\r\n    // 如果这个target是一个对象\r\n    if (!isObject(target)) { // 不是对象直接返回即可\r\n        return target;\r\n    }\r\n    // 如果对象已经被代理过了，就不要再次代理了\r\n    var existProxy = reactiveMap.get(target);\r\n    if (existProxy) {\r\n        return existProxy; // 返回上一次的代理\r\n    }\r\n    var proxy = new Proxy(target, baseHandler); // reactive核心功能就是proxy\r\n    reactiveMap.set(target, proxy); // (需要代理的对象，代理后的值)\r\n    return proxy;\r\n}\r\n","references":["/Users/zyx/study/珠峰/第八期/2021-01-23/vue3/src/shared/index.ts","/Users/zyx/study/珠峰/第八期/2021-01-23/vue3/src/reactivity/baseHandlers.ts"]}
